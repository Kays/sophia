#!/usr/bin/env perl
#                   _     _       
#   ___  ___  _ __ | |__ (_) __ _ 
#  / __|/ _ \| '_ \| '_ \| |/ _` |
#  \__ \ (_) | |_) | | | | | (_| |
#  |___/\___/| .__/|_| |_|_|\__,_|
#  =========~|_|~=================
#
#       sophia Perl IRC bot

package sophia;
require 5.10.0;
use strict;
use warnings;
use Carp qw(carp croak);
use FindBin qw($Bin);
use lib "$Bin/../src";
use POE qw(Component::IRC);
use POSIX qw(setsid);
use Sub::Delete;
use Getopt::Long;
use feature 'switch';

our %CONFIGURATIONS;
%CONFIGURATIONS = (
    VERSION         => 'sophia-1.0',
    MAIN_CONFIG     => 'sophia.conf',
    MODULES_CONFIG  => 'sophia.modules.conf',
    GLOBAL_MODULE   => 'sophia',
    IN_DEBUG_MODE   => 0,
    DO_RESTART      => 0,
);

require Main;

# don't run sophia as root idiot!
trigger_error('sophia', 'Do not run sophia as root!') if  $> == 0;

# due to lack of expertise, sophia currently does not support Windows
trigger_error('sophia', 'Currently, sophia is not supporting Windows.') if  $^O =~ /win/i;

# load configuration values
# ... and if it doesn't exist?
trigger_error('sophia', 'Missing config file.') unless -e "$Bin/../etc/$CONFIGURATIONS{MAIN_CONFIG}";

my %opts;
GetOptions(
    'debug' => \$opts{debug},
);

$CONFIGURATIONS{IN_DEBUG_MODE} = 1 if $opts{debug};

require ModuleHandler;
require SophiaGeneral;

our (%COMMANDS, %MODULES, %TIMERS, %EVENTS, %EVENTSCONF, $sophia);

%EVENTSCONF = (
    join            => 'join',
    kick            => 'kick',
    nick            => 'nick',
    notice          => 'notice',
    part            => 'part',
    privmsg         => 'privmsg',
    public          => 'public',
    quit            => 'quit',
);

my %SOPHIA = (
    admins      => {},
    channels    => {},
    ircname     => 'sophia',
    nick        => 'sophia',
    owners      => {},
    password    => '',
    port        => 6667,
    server      => 'chat.freenode.net',
    trigger     => '!',
    usermode    => '+i',
    username    => 'sophia',
    usessl      => 0,
);

# and to read the config ...
my ($pred, $val);

open CONF, "$Bin/../etc/$CONFIGURATIONS{MAIN_CONFIG}"
    or trigger_error('sophia', "Error opening config file: $!");

LINE: while (<CONF>) {
    chomp;
    s/^\s+//;
    next LINE if /^#/ or /^\s*$/ or !/\=/;  # ignoring comments and lame lines

    ($pred, $val) = split /\s*=\s*/;
    $val = substr $val, index($val, '"')+1;
    $val = substr $val, 0, index($val, '"');

    given ($pred) {
        when ("admin")    { $SOPHIA{admins}{$val} = 1; }
        when ("channel")  { $SOPHIA{channels}{$val} = 1; }
        when ("nick")     { $SOPHIA{nick} = $val; }
        when ("owner")    { $SOPHIA{owners}{$val} = 1; }
        when ("password") { $SOPHIA{password} = $val; }
        when ("port")     {
            if ( $val =~ /^\+/ ) {
                $SOPHIA{usessl} = 1;
                $val =~ s/^\+//;
            }
            $SOPHIA{port} = $val;
        }
        when ("realname") { $SOPHIA{ircname} = $val; }
        when ("server")   { $SOPHIA{server} = $val; }
        when ("trigger")  { $SOPHIA{trigger} = sprintf('\%s', $val); }
        when ("usermode") { $SOPHIA{usermode} = $val; }
        when ("username") { $SOPHIA{username} = $val; }
    }
}
close CONF;

my $pid;
unless ($CONFIGURATIONS{IN_DEBUG_MODE}) {
    $pid = fork();

    unless ($pid == 0) {
        print "sophia forked into the background with pid: $pid\n";
        sophia_log('sophia',"sophia forked into the background with pid: $pid");

        open PIDFILE, "> $Bin/../etc/sophia.pid" or trigger_error('sophia', 'Missing etc directory.');
        print PIDFILE "$pid";
        close PIDFILE;

        exit;
    }
    setsid or trigger_error('sophia', "sophia cannot start a new session: $!");
}
else {
    $pid = $$;
}

unless ($CONFIGURATIONS{IN_DEBUG_MODE}) {
    open STDIN, '/dev/null' or trigger_error('sophia', "sophia cannot read /dev/null: $!\n");
    open STDOUT, '>> /dev/null' or trigger_error('sophia', "sophia cannot write to /dev/null: $!\n");
    open STDERR, '>> /dev/null' or trigger_error('sophia', "sophia cannot write to /dev/null: $!\n");
}

$sophia = POE::Component::IRC->spawn(
    Nick        => $SOPHIA{nick},
    Username    => $SOPHIA{username},
    Password    => $SOPHIA{password},
    Ircname     => $SOPHIA{ircname},
    Server      => $SOPHIA{server},
    Port        => $SOPHIA{port},
    UseSSL      => $SOPHIA{usessl},
) or trigger_error('sophia', "Unable to spawn POE::Component::IRC: $!\n");

POE::Session->create(
    inline_states => {
        _default    => \&_default,
        _start      => \&_start,
        _stop       => \&_stop,
        irc_001     => \&irc_001,
        irc_disconnected    => \&irc_disconnected,
        irc_error   => \&irc_error,
        irc_join    => \&irc_join,
        irc_kick    => \&irc_kick,
        irc_msg     => \&irc_msg,
        irc_nick    => \&irc_nick,
        irc_notice  => \&irc_notice,
        irc_part    => \&irc_part,
        irc_public  => \&irc_public,
        irc_quit    => \&irc_quit,
        irc_shutdown    => \&irc_shutdown,
        sig_int     => \&sig_int,
        load_timers => \&load_timers,
    },
    heap => { irc => \$sophia },
);

sub _default {
	my ($event, $args) = @_[ARG0 .. $#_];
	my @output = ( "$event: " );

	for my $arg (@$args) {
		if ( ref $arg eq 'ARRAY' ) {
			push( @output, '[' . join(', ', @$arg ) . ']' );
		}
		else {
			push ( @output, "'$arg'" );
		}
	}
	print join ' ', @output, "\n";
	return 0;
}

sub _start {
    my $heap = $_[HEAP];
    my $sophia = ${$heap->{irc}};

    $_[KERNEL]->sig( INT => 'sig_int' );

    trigger_error('sophia', "Unable to get the sophia instance from heap (start): $!\n")
        unless $sophia;

    $sophia->yield( register =>  'all' );
    $sophia->yield( connect => { } );

    return;
}

sub _stop {
}

sub irc_001 {
    my $sender = $_[SENDER];
    my $sophia = $sender->get_heap();
    
    trigger_error('sophia', "Unable to get a sophia instance from heap (001): $!\n")
        unless $sophia;

    # identify to NickServ (if need be)
    $sophia->yield( privmsg => 'NickServ' => sprintf('identify %s %s', $sophia->{nick}, $sophia->{password}) )
        if $sophia->{password};

    # user modes
    $sophia->yield( mode => sprintf('%s %s', $sophia->{nick}, $SOPHIA{usermodes}) )
        if $sophia->{usermodes};

    $sophia->yield( join => $_ ) for keys %{$SOPHIA{channels}};

    # load modules
    sophia_load_modules();

    # hook up timers
    $_[KERNEL]->alarm( 'load_timers' => time() + 1 );
}

sub irc_disconnected {
    $sophia->yield('shutdown');
}

sub irc_error {
    sophia_log('sophia', $_[ARG0]);
}

sub irc_join {
    exec_events($EVENTSCONF{join}, \@_);
}

sub irc_kick {
    exec_events($EVENTSCONF{kick}, \@_);
}

sub irc_msg {
    exec_events_trigger($EVENTSCONF{privmsg}, \@_);
}

sub irc_nick {
    exec_events($EVENTSCONF{nick}, \@_);
}

sub irc_notice {
    exec_events_trigger($EVENTSCONF{notice}, \@_);
}

sub irc_part {
    exec_events($EVENTSCONF{part}, \@_);
}

sub irc_public {
    exec_events($EVENTSCONF{public}, \@_);
    exec_triggers(\@_);
}

sub irc_quit {
    exec_events($EVENTSCONF{quit}, \@_);
}

sub irc_shutdown {
    if ($CONFIGURATIONS{DO_RESTART}) {
        if ($CONFIGURATIONS{IN_DEBUG_MODE}) {
            `$Bin/sophia --debug`;
        }
        else {
            `$Bin/sophia`;
        }
    }
    exit;
}

sub sig_int {
    $sophia->yield( quit => 'Shutting down ... ' );
    $_[KERNEL]->sig_handled();
}

sub load_timers {
    sophia_load_timers(\$_[KERNEL]);
    $_[KERNEL]->alarm( 'load_timers' => time() + 60 );
}

POE::Kernel->run();

sub exec_events {
    my ($namespace, $args) = @_;

    for my $m (keys %{$sophia::EVENTS->{$namespace}}) {
        for my $c (keys %{$sophia::EVENTS->{$namespace}{$m}}) {
            eval {
                &{$sophia::EVENTS->{$namespace}{$m}{$c}{init}}($args);
                1;
            } or sophia_log('sophia', '[ERROR] ' . $!) and sophia_log('sophia', '[ERROR] '. $@);
        }
    }
}

sub exec_events_trigger {
    my ($namespace, $args) = @_;
    my @args = @{$args};
    my $content = $args[ARG2];

    # triggers ?
    return unless $content && $content =~ /^$SOPHIA{trigger}/;
    $content =~ s/^$SOPHIA{trigger}//;

    my ($module, $command, $trigger, $x);

    if (index($content, ' ') > -1) {
        $trigger = substr $content, 0, index($content, ' ');
    }
    else {
        $trigger = $content;
    }

    # global event trigger
    if ($sophia::EVENTS->{$namespace}{$CONFIGURATIONS{GLOBAL_MODULE}}{$trigger}) {
        eval {
            $x = &{$sophia::EVENTS->{$namespace}{$CONFIGURATIONS{GLOBAL_MODULE}}{$trigger}{init}}($args);
            1;
        } or sophia_log('sophia', '[ERROR] ' . $!) and sophia_log('sophia', '[ERROR] ' .$@);
    }
    # module:command trigger
    elsif ($trigger =~ m/^([^:]+):(.+)$/) {
        ($module, $command) = ($1, $2);
        if ($sophia::EVENTS->{$namespace}{$module}{$command}) {
            eval {
                $x = &{$sophia::EVENTS->{$namespace}{$module}{$command}{init}}($args);
                1;
            } or sophia_log('sophia', '[ERROR] '. $!) and sophia_log('sophia', '[ERROR] ' . $@);
        }
    }
}

sub exec_triggers {
    my $param = $_[0];
    my @args = @{$param};
    my $content = $args[ARG2];

    # triggers ?
    return unless $content && $content =~ /^$SOPHIA{trigger}/;
    $content =~ s/^$SOPHIA{trigger}//;

    my ($module, $command, $trigger, $x);

    if (index($content, ' ') > -1) {
        $trigger = substr $content, 0, index($content, ' ');
    }
    else {
        $trigger = $content;
    }

    # sophia command / global trigger?
    if ($sophia::COMMANDS->{$CONFIGURATIONS{GLOBAL_MODULE}}{$trigger}) {
        eval {
            $x = &{$sophia::COMMANDS->{$CONFIGURATIONS{GLOBAL_MODULE}}{$trigger}{init}}($param);
            1;
        } or sophia_log('sophia', '[ERROR] ' . $!) and sophia_log('sophia', '[ERROR] '. $@);
    }
    # module:command trigger
    elsif ($trigger =~ m/^([^:]+):(.+)$/) {
        $module = $1;
        $command = $2;

        if ($sophia::COMMANDS->{$module}{$command}) {
            eval {
                $x = &{$sophia::COMMANDS->{$module}{$command}{init}}($param);
                1;
            } or sophia_log('sophia', '[ERROR] ' . $!) and sophia_log('sophia', '[ERROR] '. $@);
        }
    }
}

sub is_admin {
    my $who = $_[0];
    return 0 unless $who && $SOPHIA{admins};
    return 1 if is_owner($who);

    my $host;
    for (keys %{$SOPHIA{admins}}) {
        $host = $_;
        $host =~ s/\*/.*?/g;
        return 1 if $who =~ /$host/;
    }

    return 0;
}

sub is_owner {
    my $who = $_[0];
    return 0 unless $who && $SOPHIA{owners};

    my $host;
    for (keys %{$SOPHIA{owners}}) {
        $host = $_;
        $host =~ s/\*/.*?/g;
        return 1 if $who =~ /$host/;
    }

    return 0;
}
